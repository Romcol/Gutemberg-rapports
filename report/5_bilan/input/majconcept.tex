\section{Rectificatifs de la conception}
\label{sec:majconc}

Dans ces rectificatifs, nous détaillerons les modifications que nous avons réalisées concernant la conception\cite{Conc}. Afin de pouvoir relier facilement ces rectificatifs au contenu du rapport original, nous reprendrons les mêmes titres de chapitre et nous rappellerons si nécessaire ce qui a été rédigé dans le rapport original. 

\subsection{Architecture générale}

L'architecture générale décrit dans la figure \ref{archi} de notre application n'a pas beaucoup changé. Nous avons juste utilisé la bibliothèque jQuery afin de faciliter notre développement javascript côté client.

    \begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{figure/Archi.png}
            \caption{Architecture globale de la plateforme}
            \label{archi}
    \end{figure}
		
\subsection{Architecture de la base de données}

\subsubsection{Base de données}

Le principal changement dans la modélisation de notre base de données est que la collection Tags a été remplacée par une collection \textit{AutocompleteData}. Les tags qui devaient être stockés dans la collection Tags sont en fait stockés dans une liste dans cette nouvelle collection. Nous avions besoin de stocker la liste des titres de journaux contenus dans la base de données. Nous avons donc rassemblé ces deux listes dans une même collection. Elle se nomme \textit{AutocompleteData} car elle sert notamment pour l'autocomplétion. Ainsi la collection contient deux documents :

\begin{verbatimtab}[3]
{
	‘Name’ : ‘tags’,
	‘Data’ : [ ‘Rennes’, ‘Finances’, ...]
}
{
	‘Name’ : ‘titleNewsPaper’,
	‘Data’ : [ ‘L'Aurore’, ‘Le Petit Journal’, ...]
}
\end{verbatimtab}


De même, nous avons décidé de mettre plus de données dans la liste des articles contenue dans les données des revues de presse. Ainsi, pour chaque article d'une revue de presse, nous avons son titre, sa date, le nom du journal et un extrait qui correspond au début de l'article.

Enfin, nous avons tous les noms des champs en anglais par soucis de cohérence avec le code de notre implémentation.

Le diagramme de la figure \ref{modelbdd} résume la modélisation de notre base de données.

\begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{figure/ModelBDD.png}
            \caption{Modélisation de la base de données MongoDB}
            \label{modelbdd}
\end{figure}

\subsection{Architecture de Laravel}

\subsubsection{Le modèle}

\begin{leftonly}
	Le modèle va permettre de définir des objets dans Laravel, par exemple, l'objet Article. Le modèle est en lien avec la base de données. Nous utilisons ici Elasticquent\cite{GitElasticquent} pour communiquer avec la base de données Elasticsearch et Moloquent\cite{GitLaravelMongo} pour communiquer avec MongoDB.\\ Pour toutes les requêtes d'affichage nous préférerons l'utilisation d'Elasticsearch sur MongoDB pour ces performances. MongoDB sera utilisé pour toutes les requêtes d'ajout et de modification de la base de données, ces données seront bien sûr répliquées sur Elasticsearch.
\end{leftonly}

Nous avons, en fait, utilisé la bibliothèque Bouncy\cite{GitBouncy} pour gérer la communication entre Laravel et Elasticsearch. Nous avions beaucoup trop de difficultés à utiliser Elasticquent comme nous le voulions. Nous avons donc changé de bibliothèque.

\subsubsection{Authentification}

Cette partie ne se trouvait pas dans le rapport original. Nous avons utilisé le système d'authentification pré-implémenté dans Laravel pour l'inscription et la connexion des utilisateurs. En effet, Laravel propose un ensemble de fichiers ( contrôleurs, vues, ... ) qui permet de gérer l'authentification. Nous avons ainsi un système d'authentification simple et rapide à mettre en place qui inclus le chiffrage du mot de passe et un système de récupération de mot de passe qui envoie un lien par mail pour réinitialiser le mot de passe. Il est possible de modifier le comportement de ce système en surchargeant les méthodes afin d'ajouter des fonctionnalités. Pour notre application, nous avons juste à traduire en français les messages donnés à l'utilisateur lorsqu'il remplit mal les champs ou que les identifiants existent déjà dans la base.
